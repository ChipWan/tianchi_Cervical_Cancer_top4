"""
    @lichenyang 2019.12.02

    Generate the final result into json file using the txt files generated by gen_pred_bbox.py

    Step:
      1. Combine the results of silding wins for each model.
      2. Combine the results of diff models.
      3. Dump to the json file.
        * filter out the small pred bboxes.

"""

import os
import os.path as osp
import json
import time
import pdb

import argparse

import numpy as np

from tqdm import tqdm

from ensemble_boxes import *


def parse_args():
  """
  Parse input arguments
  """
  parser = argparse.ArgumentParser(description='Generate the final result.')

  parser.add_argument('--txt_roots', dest='txt_roots',
                      help='the txt directories to be combined.',
                      nargs='+', type=str, default='')
  parser.add_argument('--json_root', dest='json_root',
                      help='directory to the res json',
                      default="./")

  # Fusion within a sliding windows.
  parser.add_argument('--win_fusion', dest='win_fusion',
                      help='fuse the results within a sliding window.',
                      action='store_true')
  parser.add_argument('--win_fusion_method', dest='win_fusion_method',
                      help='the method to fuse the bboxes',
                      type=str, default='nms')  # nms or vote_max or vote_avg
  parser.add_argument('--win_fusion_thred', dest='win_fusion_thred',
                      help='iou thred to fuse the bbox',
                      default=0.3, type=float)

  # Fusion within a roi.
  parser.add_argument('--roi_fusion', dest='roi_fusion',
                      help='fuse the results within a roi.',
                      action='store_true')
  parser.add_argument('--roi_fusion_method', dest='roi_fusion_method',
                      help='the method to fuse the bboxes',
                      type=str, default='vote_max')  # vote_max or vote_avg
  parser.add_argument('--roi_fusion_thred', dest='roi_fusion_thred',
                      help='iou thred to fuse the bbox',
                      default=0.3, type=float)

  # Fusion of diff models.
  parser.add_argument('--model_fusion', dest='model_fusion',
                      help='fuse the results from diff models.',
                      action='store_true')
  parser.add_argument('--model_fusion_method', dest='model_fusion_method',
                      help='the method to fuse the bboxes',
                      type=str, default='vote_wbf')  # vote_max or vote_avg or vote_wbf or concate
  parser.add_argument('--model_fusion_thred', dest='model_fusion_thred',
                      help='iou thred to fuse the bbox',
                      default=0.3, type=float)
  parser.add_argument('--model_weights', dest='model_weights',
                      help='The weights ofor each model.',
                      nargs='+', type=int, default=None)

  parser.add_argument('--filter_size', dest='filter_size',
                      help='filter out the pred bboxes smaller than filter_size',
                      default=3, type=int)

  parser.add_argument('--sliding_win_size', dest='sliding_win_size', \
                    nargs='+', type=int, default=[800, 800], help='The size of sliding windows.')  

  parser.add_argument('--src_img_size_json', dest='src_img_size_json',
                      help='the dir to the json saving the src img size',
                      default="/home/admin/jupyter/Datasets/src_kfb_img_size.json")


  args = parser.parse_args()
  return args


def load_decode_txt(txt_dir):
  """
    Load the txt and decode the coord back to the src img.
    - outputs:
      res: np.array, (N, 6)
  """

  with open(txt_dir) as f:
    lines = f.readlines()

    if len(lines) == 0:
      return np.zeros((0, 6))
    else:
      res = []
      for line in lines:
        cont = line.strip().split()
        # x1 = np.clip(float(cont[0]), 0, win_size[0] - 1)
        # y1 = np.clip(float(cont[1]), 0, win_size[1] - 1)
        # x2 = np.clip(float(cont[2]), 0, win_size[0] - 1)
        # y2 = np.clip(float(cont[3]), 0, win_size[1] - 1)
        x1 = float(cont[0])
        y1 = float(cont[1])
        x2 = float(cont[2])
        y2 = float(cont[3])
        cls_id = float(cont[4])
        score = float(cont[5])

        res.append([x1, y1, x2, y2, cls_id, score])

        # print(res)

  res = np.array(res)

  res = decode_coord(txt_dir, res)

  return res


def decode_coord(txt_dir, coord):
  """
    Translate the coord from win to original img.
  """

  txt_name = osp.basename(txt_dir)
  # print(txt_name)
  cont = txt_name.split('.')[0].split('_')
  lt_x = int(cont[2])
  lt_y = int(cont[3])

  coord[:, 0] = coord[:, 0] + lt_x
  coord[:, 1] = coord[:, 1] + lt_y
  coord[:, 2] = coord[:, 2] + lt_x
  coord[:, 3] = coord[:, 3] + lt_y

  return coord


def load_org_pred(txt_root):
  """
    Load the orginal pred result as a dict.
    - outputs:
      recursive dict: res[src_img_name][roi_name][txt_name], the value is a np.array of shape (N, 6)
  """

  res = {}

  src_img_names = os.listdir(txt_root)

  # for src_img_name in tqdm(src_img_names):
  for src_img_name in tqdm(src_img_names):
  # for src_img_name in tqdm(['5083', '7657']):
    img_dir = osp.join(txt_root, src_img_name)
    roi_names = os.listdir(img_dir)
    res[src_img_name] = {}

    for roi_name in roi_names:
      roi_dir = osp.join(img_dir, roi_name)
      txt_names = os.listdir(roi_dir)
      res[src_img_name][roi_name] = {}
      for txt_name in txt_names:
        txt_dir = osp.join(roi_dir, txt_name)
        res[src_img_name][roi_name][txt_name] = load_decode_txt(txt_dir)

  return res


def get_cls_types():

  CELL_TYPES = (
      'ASC-H',    # 6194
      'ASC-US',   # 5945
      'HSIL',     # 2818
      'LSIL',     # 3382
      'Candida',  # 1651
      'Trichomonas',  # 11510
      )

  return CELL_TYPES



def one_cls_vote(dets, vote_iou_thred, fuse_method):

  x1 = dets[:, 0]
  y1 = dets[:, 1]
  x2 = dets[:, 2]
  y2 = dets[:, 3]
  scores = dets[:, 5]

  areas = (x2 - x1 + 1) * (y2 - y1 + 1)
  order = scores.argsort()[::-1]

  # ids = np.where(areas == 0)[0]
  # if ids.shape[0] > 0:
  #   print(x1[ids], x2[ids], y1[ids], y2[ids])

  # keep = []
  cur_bbox = []
  res_bbox = []
  while order.size > 0:
      i = order.item(0)
      # keep.append(i)
      cur_bbox.append(dets[i, :])

      xx1 = np.maximum(x1[i], x1[order[1:]])
      yy1 = np.maximum(y1[i], y1[order[1:]])
      xx2 = np.minimum(x2[i], x2[order[1:]])
      yy2 = np.minimum(y2[i], y2[order[1:]])

      w = np.maximum(0.0, xx2 - xx1 + 1)
      h = np.maximum(0.0, yy2 - yy1 + 1)
      inter = w * h

      ovr = inter / (areas[i] + areas[order[1:]] - inter)

      inds_keep = np.where(ovr <= vote_iou_thred)[0]
      inds_vote = np.where(ovr > vote_iou_thred)[0]
      # print("inds_vote", inds_vote.shape[0])

      for j in range(inds_vote.shape[0]):
        cur_bbox.append(dets[order[inds_vote[j] + 1], :])

      # if len(cur_bbox) > 1:
      #   print("len(cur_bbox) larger than 1.")
      #   raise
      res_bbox.append(bbox_voting(cur_bbox, fuse_method))
      cur_bbox = []
      order = order[inds_keep + 1]

  res_bbox = np.array(res_bbox)

  return res_bbox


def bbox_voting(bbox_list, fuse_method):
  bbox_num = len(bbox_list)
  if bbox_num == 1:
    return bbox_list[0]

  bbox_arr = np.array(bbox_list)
  score_sum = np.sum(bbox_arr[:, 5])
  score_max = np.max(bbox_arr[:, 5])

  res_vote = np.zeros(6)

  w = bbox_arr[:, 5] / score_sum

  res = bbox_arr[:, :4] * w[:, np.newaxis]
  # print(res.shape)

  res_vote[:4] = np.sum(res, axis=0)
  res_vote[4] = bbox_list[0][4]
  if fuse_method == 'vote_max':
    res_vote[5] = score_max
  elif fuse_method == 'vote_avg':
    res_vote[5] = score_sum / bbox_num

  # print(bbox_arr, res_vote)


  return res_vote




def multi_cls_vote(dets, thred, fuse_method):
  """
    Do multi cls voting.
    - inputs:
      dets: np.array(N, 6), (x1, y1, x2, y2, cls_id, score)
    - outputs:
      res: np.array(N, 6), (x1, y1, x2, y2, cls_id, score)
  """

  cls_types = get_cls_types()
  cls_num = len(cls_types)
  res = []

  for i in range(cls_num):
    cur_cls_id = np.where(dets[:, 4] == i+1)[0]
    if len(cur_cls_id) == 0:
      continue
    cur_clc_det = one_cls_vote(dets[cur_cls_id, :], thred, fuse_method)

    res.append(cur_clc_det)


  if len(res) == 0:
    return np.zeros((0, 6))
  else:
    res = np.vstack(res)
    return res




def do_win_fusion(pred_dets, args):
  """
    Fuse the res within each win.
  """


  if 'vote' in args.win_fusion_method:
    for img_name in pred_dets.keys():
      for roi_name in pred_dets[img_name].keys():
        for txt_name in pred_dets[img_name][roi_name].keys():
          pred_det = pred_dets[img_name][roi_name][txt_name]
          pred_det = multi_cls_vote(pred_det, 
                      args.win_fusion_thred, args.win_fusion_method)
          pred_dets[img_name][roi_name][txt_name] = pred_det
  else:
    raise

  return pred_dets


def do_roi_fusion(pred_dets, args):
  """
    Fuse the res within each roi.
    - inputs:
      pred_dets: recursive dict. pred_dets[src_img_name][roi_name][txt_name], the value is a np.array of shape (N, 6)
    - outputs:
      res: dict. res[src_img_name], the value is a np.array of shape (N, 6)
  """

  res = {}

  for img_name in pred_dets.keys():
    cur_img_res = []
    for roi_name in pred_dets[img_name].keys():
      cur_roi_res = np.vstack([pred_dets[img_name][roi_name][k] \
        for k in pred_dets[img_name][roi_name].keys()])
      # pdb.set_trace()
      cur_roi_res = multi_cls_vote(cur_roi_res, \
        args.roi_fusion_thred, args.roi_fusion_method)
      # pdb.set_trace()
      cur_img_res.append(cur_roi_res)

    res[img_name] = np.vstack(cur_img_res)

  return res



def get_pred_res_one_model(txt_root, args):
  """
    Fuse the pred results of sliding wins and rois for one model.
    - outputs:
      pred_dets (with args.roi_fusion): dict. pred_dets[src_img_name], the value is a np.array of shape (N, 6)
      pred_dets (w/o args.roi_fusion): dict. pred_dets[src_img_name][roi_name][txt_name], the value is a np.array of shape (N, 6)
  """

  pred_dets = load_org_pred(txt_root)

  # pdb.set_trace()

  if args.win_fusion:
    pred_dets = do_win_fusion(pred_dets, args)

  if args.roi_fusion:
    pred_dets = do_roi_fusion(pred_dets, args)


  return pred_dets





def arr_to_json_list(res_arr, args):

  res = []
  cls_types = get_cls_types()

  for i in range(res_arr.shape[0]):
    x = int(res_arr[i][0])
    y = int(res_arr[i][1])
    w = int(res_arr[i][2] - res_arr[i][0] + 1)
    h = int(res_arr[i][3] - res_arr[i][1] + 1)
    cls_str = cls_types[int(res_arr[i][4]) - 1]
    score = float(res_arr[i][5])

    if w <= args.filter_size or h <= args.filter_size:
      print('drop')
      continue

    dict_cur = {}
    dict_cur['x'] = x
    dict_cur['y'] = y
    dict_cur['w'] = w
    dict_cur['h'] = h
    dict_cur['p'] = score
    dict_cur['class'] = cls_str

    res.append(dict_cur)

  # pdb.set_trace()

  return res





def dump_to_json(res, args):
  """
    Dump the final pred res into json files.
    -inputs:
      res: dict. 
        key: src_img_name.
        value: np.array. (N, 6)
    - json files: list(dict), each dict is for one pred bbox.
      keys: x, y, w, h, p, class
  """

  res_json = {}
  json_root = args.json_root

  for k in res.keys():

    res_json[k] = arr_to_json_list(res[k], args)

    json_dir = osp.join(json_root, '{}.json'.format(k))
    with open(json_dir, 'w') as f:
      json.dump(res_json[k], f)




def get_pred_res_diff_models(model_list, args):
  """
    Combine the pred res of diff models.
    - inputs；
      model_list: list(dict)
  """



  model_num = len(model_list)

  assert model_num > 0

  if model_num == 1:
    return model_list[0]


  if args.model_fusion_method == 'concate':
    res = do_model_concate(model_list, args)
  elif args.model_fusion_method == 'vote_wbf':
    res = do_model_wbf(model_list, args)


  return res


def do_model_concate(model_list, args):
  """
    Directly concatenate the results of different models.
  """

  res = {}

  model_num = len(model_list)

  for k in model_list[0].keys():

    res[k] = np.vstack([model_list[i][k] for i in range(model_num)])


  return res



def do_model_wbf(model_list, args):
  """
    Do WBF (Weighted boxes fusion).
    Refer to https://github.com/ZFTurbo/Weighted-Boxes-Fusion
  """

  with open(args.src_img_size_json, 'r') as f:
    src_img_size = json.load(f)


  res = {}

  model_num = len(model_list)

  print("WBF voting.")

  for k in tqdm(model_list[0].keys()):

    src_img_width = src_img_size[k]['width']
    src_img_height = src_img_size[k]['height']

    # Norm the coord to [0, 1], to match the input format of weighted_boxes_fusion()
    for i in range(model_num):
      model_list[i][k][:, 0] /= src_img_width
      model_list[i][k][:, 1] /= src_img_height
      model_list[i][k][:, 2] /= src_img_width
      model_list[i][k][:, 3] /= src_img_height

      if (model_list[i][k][:, :4]>1).any():
        print(i, k, "The normalization edge is larger than 1.")


    boxes_list = [list(model_list[i][k][:, :4]) for i in range(model_num)]
    scores_list = [list(model_list[i][k][:, 5]) for i in range(model_num)]
    labels_list = [list(model_list[i][k][:, 4]) for i in range(model_num)]

    if args.model_weights is None:
      weights = [1 for _ in range(model_num)]
    else:
      weights = args.model_weights
    iou_thr = args.model_fusion_thred
    skip_box_thr = 0.0001

    boxes, scores, labels = \
      weighted_boxes_fusion(boxes_list, scores_list, labels_list, weights=weights, iou_thr=iou_thr, skip_box_thr=skip_box_thr)


    boxes = np.array(boxes)
    # denorm thre coord to src img size
    boxes[:, 0] *= src_img_width
    boxes[:, 1] *= src_img_height
    boxes[:, 2] *= src_img_width
    boxes[:, 3] *= src_img_height

    res[k] = np.hstack([boxes, labels[ :, np.newaxis], scores[:, np.newaxis]])
    # pdb.set_trace()

  return res




if __name__ == '__main__':
  args = parse_args()

  print('Called with args:')
  print(args)

  if not osp.exists(args.json_root):
    os.makedirs(args.json_root)


  res_models = [] # res of diff models


  # 1. Combine the res for each model.
  for i, txt_root in enumerate(args.txt_roots):
    res = get_pred_res_one_model(txt_root, args)

    res_models.append(res)


  # pdb.set_trace()


  # 2. Combine the res of diff models.
  if args.model_fusion:
    res = get_pred_res_diff_models(res_models, args)

  # pdb.set_trace()


  # 3 Dump to json file
  dump_to_json(res, args)

